<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC
    "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN"
    "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xml:lang='en' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/1999/xhtml'>
<head><meta content='application/xhtml+xml;charset=utf-8' http-equiv='Content-type' /><title>XML PROCESSING UTILITIES 2.0</title></head>
<body><style>
  table { border-collapse: collapse; }
  td { border: 1px solid black;
       padding: 10px;
	 }
  caption { padding 20px; }
  pre { border: 1px solid black;
		padding: 10px;
		background-color: rgba(65, 131, 196, 0.4);
      }
</style>
<h1 id='xml_processing_utilities_20'>XML PROCESSING UTILITIES 2.0</h1>

<h2 id='revision_history'>Revision History</h2>

<p>TODO: Include all history from older manual. Latest version updated by Sam Habiel in July 2013.</p>

<h2 id='introduction'>Introduction</h2>

<p>VISTA XML Processing Utilities cover 4 different domains:</p>

<ul>
<li>XML Parsing</li>

<li>XML Querying using XPATH</li>

<li>XML Creation tools</li>

<li>XML Templating</li>
</ul>

<h2 id='xml_parsing'>XML Parsing</h2>

<p>The VistA Extensible Markup Language (XML) Parser is a full-featured, validating XML parser written in the M programming language and designed to interface with the VistA suite of M-based applications. It is not a standalone product. Rather, it acts as a server application that can provide XML parsing capabilities to any client application that subscribes to the application programmer interface (API) specification detailed in this document.</p>

<p>The VistA XML Parser employs two very different API implementations. The first is an event-driven interface that is modeled after the widely used Simple API for XML (SAX) interface specification. In this implementation, a client application provides a special handler for each parsing event of interest. When the client invokes the parser, it conveys not only the document to be parsed, but also the entry points for each of its event handlers. As the parser progresses through the document, it invokes the client’s handlers for each parsing event for which a handler has been registered.</p>

<p>The second API implementation is based on the World Wide Web Consortium (W3C’s) Document Object Model (DOM) specification. This API, which is actually built on top of the event-driven interface, first constructs an in-memory model of the fully parsed document. It then provides methods to navigate through and extract information from the parsed document.</p>

<p>The choice of which API to employ is in part dependent on the needs of the application developer. The event-driven interface requires the client application to process the document in a strictly top-down manner. In contrast, the in-memory model provides the ability to move freely throughout the document and has the added advantage of ensuring that the document is well formed and valid before any information is returned to the client application.</p>

<p>The VistA XML Parser employs an Entity Catalog to allow storage of external entities such as document type definitions. The Entity Catalog is a VA FileMan-compatible database and can be manipulated using the usual VA FileMan tools.</p>

<h3 id='term_definitions_and_xml_parser_concept'>Term Definitions and XML Parser Concept</h3>

<p>To understand the terms used in this documentation and the concept of the operation of an XML Parser, please review the W3C Architecture Domain website, Extensible Markup Language (XML) page at: <a href='http://www.w3.org/XML/'>http://www.w3.org/XML/</a>.</p>

<h3 id='known_issues'>Known Issues</h3>

<p>The following are known issues in this version of the XML parser. Some of these are due to certain limitations of the M programming language.</p>

<p>Unlike languages like Java that have multiple character encoding support built-in, M does not recognize character encodings that do not incorporate the printable ASCII character subset. Thus, 16-bit character encodings such as Unicode are not supported. Fortunately, a large number of 8-bit character encodings do incorporate the printable ASCII character subset and can be parsed. Because of this limitation, the VistA XML Parser will reject any documents with unsupported character encodings.</p>

<p>The current version of the VistA XML Parser does not support retrieval of external entities using the HTTP or FTP protocols (or for that matter, any protocols other than the standard file access protocols of the underlying operating system). Client applications using the event-driven interface can intercept external entity retrieval by the parser and implement support for these protocols if desired.</p>

<p>The parser uses the Kernel function FTG^%ZISH for file access. This function reads the entire contents of a file into an M global. There are several nuances to this function that manifest themselves in parser operation:</p>

<blockquote>
<p>Files are opened with a time-out parameter. If an attempt is made to access a non-existent file, there is a delay of a few seconds before the error is signaled.</p>
</blockquote>

<p>FTG^%ZISH doesn&#8217;t work on GT.M because of the %ZISH call is non-supported. Instead, the programmer must load the file into a global first and send that global into the parser.</p>

<p>Files are accessed in text mode. The result is that certain imbedded control characters are stripped from the input stream and never detected by the parser. Because these control characters are disallowed by XML, the parser will not report such documents as non-conforming.</p>

<blockquote>
<p>A line feed / carriage return sequence at the end of a document is stripped and not presented to the parser. Only in rare circumstances would this be considered significant data, but in the strictest sense should be preserved.</p>
</blockquote>

<p>The parser allows external entities to contain substitution text that in some cases would violate XML rules that state that a document must be conforming in the absence of resolving such references. In other words, XML states that a non-validating parser should be able to verify that a document is conforming without processing external entities. This restriction constrains how token streams can be continued across entities. The parser recognizes most, but not all, of these restrictions. The effect is that the parser is more lax in allowing certain kinds of entity substitutions.</p>

<p>Parsers vary in how they enforce whitespace that is designated as required by the XML specification. This parser will flag the absence of any required whitespace as a conformance error, even in situations where the absence of such whitespace would not introduce syntactic ambiguity. The result is that this parser will reject some documents that may be accepted by other parsers.</p>

<h3 id='eventdriven_api'>Event-Driven API</h3>

<p>The event-driven Application Programmer Interface (API) is based on the well-established Simple API for XML (SAX) interface employed by many XML parsers. This API, Table 1, has a single method. (Figure 1 spans two pages.)</p>

<h4 id='enmxmlprsedoccbkopt'>EN^MXMLPRSE(DOC,CBK,OPT)</h4>
<table>
<caption>Table 1: EN^MXMLPRSE—Event-Driven API based on SAX interface</caption>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required?</th>
<th>Description</th>
</tr>
<tr>
<td><strong>DOC</strong></td>
<td>String</td>
<td>Yes</td>
<td>This is either a closed reference to a global root
containing the document or a filename and path
reference identifying the document on the host
system. If a global root is passed, the document
must either be stored in standard FileMan word-
processing format or may occur in sequentially
numbered nodes below the root node. Thus, if the
global reference is “^XYZ”, the global must be of one
of the following formats:<br />
<pre>
^XYZ(1,0) = "LINE 1"
^XYZ(2,0) = "LINE 2" ...
</pre>
or<br />
<pre>
^XYZ(1) = "LINE 1"
^XYZ(2) = "LINE 2" ...
</pre>
</td>
</tr>
<tr>
<td>CBK</td>
<td>Local array (by reference)</td>
<td>No</td>
<td>This is a local array, passed by reference that
contains a list of parse events and the entry points
for the handlers of those events. The format for each
entry is:<br />
<pre>
CBK(&lt;event type&gt;) = &lt;entry point&gt;
</pre><br />
The entry point must reference a valid entry point in
an existing M routine and should be of the format
tag^routine. The entry should not contain any formal
parameter references. The application developer is
responsible for ensuring that the actual entry point
contains the appropriate number of formal
parameters for the event type. For example, client
application might register its STARTELEMENT event
handler as follows:<br />
<pre>
CBK(“STARTELEMENT”) = “STELE^CLNT”
</pre>
The actual entry point in the CLNT routine must
include two formal parameters as in the example:<br />
<pre>
STELE(ELE,ATR) &lt;handler code&gt;
</pre>
For the types of supported events and their required
parameters, see the discussion on the pages that
follows.
</td>
</tr>
<tr>
<td>OPT</td>
<td>String</td>
<td>No</td>
<td>This is a list of option flags that control parser
behavior. Recognized option flags are:
<ul>
 <li>W = Do not report warnings to the client.</li>
 <li>V = Validate the document. If not specified, the
  parser only checks for conformance.</li>
 <li>0 = Terminate parsing on encountering a
   warning.</li>
 <li>1 = Terminate parsing on encountering a
	validation error. (By default, the parser
	terminates only when a conformance error is
	encountered.) </li>
</ul>
</td>
</tr>
</table>
<h4 id='event_types_recognized_by_vista_xml_parser'>Event Types Recognized by Vista XML Parser</h4>
<table>
<caption>Table 2: Event types recognized by the VISTA XML Parser</caption>
<tr>
<th>Event Type</th>
<th>Parameter(s)</th>
<th>Description</th>
</tr>
<tr>
<td><strong>STARTDOCUMENT</strong></td>
<td>None</td>
<td>Notifies the client that document parsing has commenced.</td>
</tr>
<tr>
<td><strong>ENDDOCUMENT</strong></td>
<td>None</td>
<td>Notifies the client that document parsing has completed.</td>
</tr>
<tr>
<td><strong>DOCTYPE</strong></td>
<td>ROOT <br />
PUBID <br />
SYSID</td>
<td>Notifies the client that a DOCTYPE declaration
has been encountered. The name of the
document root is given by ROOT. The public and
system identifiers of the external document type
definition are given by PUBID and SYSID,
		   respectively.</td>
</tr>
<tr>
	<td><strong>STARTELEMENT</strong></td>
	<td>NAME <br />
	ATTRLIST</td>
	<td>An element (tag) has been encountered. The
	name of the element is given in NAME. The list of
	attributes and their values is provided in the local
	array ATTRLST in the format:

	ATTRLST(&lt;name&gt;) = &lt;value&gt;
	</td>
</tr>
<tr>
	<td><strong>ENDELEMENT</strong></td>
	<td>NAME</td>
	<td>A closing element (tag) has been encountered.
	The name of the element is given in NAME.</td>
</tr>
<tr>
	<td><strong>CHARACTERS</strong></td>
	<td>NAME</td>
	<td>
	Non-markup content has been encountered.
	TEXT contains the text. Line breaks within the
	original document are represented as carriage
	return/line feed character sequences. The parser
	does not necessarily pass an entire line of the
	original document to the client with each event of
	this type.</td>
</tr>
<tr>
	<td><strong>PI</strong></td>
	<td>TARGET<br />
	    TEXT</td>
	<td>The parser has encountered a processing
	instruction. TARGET is the target application for
	the processing instruction. TEXT is a local array
	containing the parameters for the instruction.</td>
</tr>
<tr>
	<td><strong>EXTERNAL</strong></td>
	<td>SYSID<br />
	    PUBID<br />
		GLOBAL</td>
	<td>The parser has encountered an external entity
	reference whose system and public identifiers are
	given by SYSID and PUBID, respectively. If the
	event handler elects to retrieve the entity rather
	than allowing the parser to do so, it should pass
	the global root of the retrieved entity in the
	GLOBAL parameter. If the event handler wishes
	to suppress retrieval of the entity altogether, it
	should set both SYSID and PUBID to null.</td>
</tr>
<tr>
	<td><strong>NOTATION</strong></td>
	<td>NAME<br />
	    SYSID<br />
		PUBIC</td>
	<td>The parser has encountered a notation
	declaration. The notation name is given by
	NAME. The system and public identifiers
	associated with the notation are given by SYSID
	and PUBIC, respectively.</td>
</tr>
<tr>
	<td><strong>COMMENT</strong></td>
	<td>TEXT</td>
	<td>The parser has encountered a comment. TEXT is
	the text of the comment.</td>
</tr>
<tr>
	<td><strong>ERROR</strong></td>
	<td>ERR</td>
	<td>The parser has encountered an error during the
	processing of a document. ERR is a local array
	containing information about the error. The
	format is:
	<ul>
	<li>ERR("SEV") = Severity of the error where 0 is a
	warning, 1 is a validation error, and 2 is a
	conformance error.</li>
	<li>ERR("MSG") = Brief text description of the
	error.</li>
	<li>ERR("ARG") = The token value the triggered
	the error (optional).</li>
	<li>ERR("LIN") = The number of the line being
	processed when the error occurred.</li>
	<li>ERR("POS") = The character position within
	the line where the error occurred.</li>
	<li>ERR("XML") = The original document text of
	the line where the error occurred.</li>
	</ul>
	</td>
</tr>
</table>
<p>A sample client of the event-driven API is provided in the routine MXMLTEST. This routine has an entry point EN(DOC,OPT), where DOC and OPT are the same parameters as described above in Table 2 for the parser entry point. This sample application simply prints a summary of the parsing events as they occur.</p>

<h3 id='inmemory_document_api'>In-Memory Document API</h3>

<p>This Application Programmer Interface (API) is based on the W3C’s Document Object Model (DOM) specification. It first builds an “in-memory” image of the fully parsed and validated document and then provides a set of methods to permit structured traversal of the document and extraction of its contents. This API is actually layered on top of the event-driven API. In other words, it is actually a client of the event-driven API that in turn acts as a server to another client application.</p>

<p>The document image is represented internally as a tree with each node in the tree representing an element instance. Attributes (names and values), non-markup text, and comment text may be associated with any given node. For example, in Table 3 the XML document on the left is represented by the tree structure on the right.</p>
<table>
<caption>Table 3: XML document (left) – Tree structure diagram (right)</caption>
<tr>
	<td>
	<pre>
	&lt;top attr1="val1" attr2="val2"&gt;
	&lt;child1&gt;child1 text&lt;/child1&gt;
	&lt;child2&gt;child2 text&gt;&lt;/child2&gt;
	&lt;/top&gt;
	</pre>
	</td>
	<td>
	<strong>top</strong> (attr1 = val1; attr2 = val2)
	<ul>
	<li>Child1 (Child1 text)</li>
	<li>Child2 (Child2 text)</li>
	</ul>
	</td>
</tr>
</table>
<p>The supported methods are documented on the pages that follow.</p>

<h4 id='enmxmldomdocopt'>$$EN^MXMLDOM(DOC,OPT)</h4>

<p>This is the entry point to perform initial processing of the XML document. The client application must first call this entry point to build the in-memory image of the document before the remaining methods can be applied. The return value is a handle to the document instance that was created and is used by the remaining API calls to identify a specific document instance. The parameters for this entry point are listed in Table 4 by type, requirement (yes or no), and description. <table>
<caption>Table 4: $$EN^MXMLDOM - Perform inital processing of XML document</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>DOC</td>
	<td>String</td>
	<td>Yes</td>
	<td>Either a closed reference to a global root containing
	the document or a filename and path reference
	identifying the document on the host system. If a
	global root is passed, the document must either be
	stored in standard FileMan word-processing format
	or may occur in sequentially numbered nodes below
	the root node. Thus, if the global reference is
	"^XYZ", the global must be of one of the following
	formats:
	<pre>
	^XYZ(1,0) = "LINE 1"
	^XYZ(2,0) = "LINE 2" ...
	</pre>
	or
	<pre>
	^XYZ(1) = "LINE 1"
	^XYZ(2) = "LINE 2" ...
	</pre>
	</td>
</tr>
<tr>
	<td>OPT</td>
	<td>String</td>
	<td>No</td>
	<td>
		<ul>
			<li> W = Do not report warnings to the client.</li>
			<li> V = Do not validate the document. If specified,
			the parser only checks for conformance.</li>
			<li> 0 = Terminate parsing on encountering a
			warning.</li>
			<li> 1 = Terminate parsing on encountering a validation
			error. (By default, the parser terminates only when a
			conformance error is encountered.)</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Return value</td>
	<td>Integer</td>
	<td>&nbsp;</td>
	<td>Returns a nonzero handle to the document instance
	if parsing completed successfully, or zero otherwise.
	This handle is passed to all other API methods to
	indicate which document instance is being
	referenced. This allows for multiple document
	instances to be processed concurrently.</td>
</tr>
</table></p>

<h4 id='deletemxmldomhandle'>DELETE^MXMLDOM(HANDLE)</h4>

<p>This entry point deletes the specified document instance. A client application should always call this entry point when finished with a document instance. The parameter for this API is listed in Table 5 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 5: DELETE^MXMLDOM—Delete specified document instance</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
</table>
<h4 id='namemxmldomhandlenode'>$$NAME^MXMLDOM(HANDLE,NODE)</h4>

<p>This entry point returns the name of the element at the specified node within the document parse tree. The parameters for this API are listed in Table 6 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 6: $$NAME^MXMLDOM—Return element name at specified node in document parse tree</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node whose associated element name is being
	retrieved.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>The name of the element associated with the
	specified node.</td>
</tr>
</table>
<h4 id='childmxmldomhandleparentchild'>$$CHILD^MXMLDOM(HANDLE,PARENT,CHILD)</h4>

<p>Returns the node of the first or next child of a given parent node, or 0 if there are none remaining. The parameters for this API are listed in Table 7 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 7: $$CHILD^MXMLDOM—Return parent node’s first or next child. 0 if none remaining.</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>PARENT</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node whose children are being retrieved.</td>
</tr>
<tr>
	<td>CHILD</td>
	<td>Integer</td>
	<td>No</td>
	<td>If specified, this is the last child node retrieved. The
	function will return the next child in the list. If the
	parameter is zero or missing, the first child is
	returned.</td>
</tr>
<tr>
	<td>Return Value</td>
	<td>Integer</td>
	<td>&nbsp;</td>
	<td>The next child node or zero if there are none
	remaining.</td>
</tr>
</table>
<h4 id='siblingmxmldomhandlenode'>$$SIBLING^MXMLDOM(HANDLE,NODE)</h4>

<p>Returns the node of the specified node’s immediate sibling, or 0 if there is none. The parameters for this API are listed in Table 8 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 8: $$SIBLING^MXMLDOM—Return specified node’s immediate sibling. 0 if none remaining</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node in the document tree whose sibling is
	being retrieved.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>Integer</td>
	<td>&nbsp;</td>
	<td>The node corresponding to the immediate sibling of
	the specified node, or zero if there is none.</td>
</tr>
</table>
<h4 id='parentmxmldomhandlenode'>$$PARENT^MXMLDOM(HANDLE,NODE)</h4>

<p>Returns the parent node of the specified node, or 0 if there is none. The parameters for this API are listed in Table 9 by type, requirement (yes or no), and description. <table>
<caption>Table 9: $$PARENT^MXMLDOM—Return specified node’s parent node. 0 if none remaining</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node in the document tree whose parent is
	being retrieved.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>&nbsp;</td>
	<td>
	 The parent node of the specified node, or zero if there is no parent.
	</td>
</tr>
</table></p>

<h4 id='textmxmldomhandlenodetext_or_textmxmldomhandlenodetext'>TEXT^MXMLDOM(HANDLE,NODE,TEXT) or $$TEXT^MXMLDOM(HANDLE,NODE,TEXT)</h4>

<p>Extracts non-markup text associated with the specified node. The parameters for this API are listed in Table 10 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 10: TEXT^MXMLDOM or $$TEXT^MXMLDOM—Extract specified node’s non-markup text</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node in the document tree that is being
	referenced by this call.</td>
</tr>
<tr>
	<td>TEXT</td>
	<td>String</td>
	<td>Yes</td>
	<td>This parameter must contain a closed local or global
	array reference that is to receive the text. The
	specified array is deleted before being populated.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>Boolean</td>
	<td>&nbsp;</td>
	<td>If called as an extrinsic function, the return value is
	true if text was retrieved, or false if not.</td>
</tr>
</table>
<h4 id='cmntmxmldomhandlenodetext_or_cmntmxmldomhandlenodetext'>CMNT^MXMLDOM(HANDLE,NODE,TEXT) or $$CMNT^MXMLDOM(HANDLE,NODE,TEXT)</h4>

<p>Extracts comment text associated with the specified node. The parameters for this API are listed in Table 11 by type, requirement (yes or no), and description. <table>
<caption>Table 11: CMNT^MXMLDOM or $$CMNT^MXMLDOM—Extract specified node’s comment text</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node in the document tree that is being
	referenced by this call.</td>
</tr>
<tr>
	<td>TEXT</td>
	<td>String</td>
	<td>Yes</td>
	<td>This parameter must contain a closed local or global
	array reference that is to receive the text. The
	specified array is deleted before being populated.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>Boolean</td>
	<td>&nbsp;</td>
	<td>If called as an extrinsic function, the return value is
	true if text was retrieved, or false if not.</td>
</tr>
</table></p>

<h4 id='attribmxmldomhandlenodeattrib'>$$ATTRIB^MXMLDOM(HANDLE,NODE,ATTRIB)</h4>

<p>Retrieves the first or next attribute associated with the specified node. The parameters for this API are listed in Table 12 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 12: $$ATTRIB^MXMLDOM—Retrieve specified node’s first or next attribute</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node whose attribute name is being retrieved.</td>
</tr>
<tr>
	<td>ATTRIB</td>
	<td>String</td>
	<td>No</td>
	<td>The name of the last attribute retrieved by this call. If
	null or missing, the first attribute associated with the
	specified node is returned. Otherwise, the next
	attribute in the list is returned.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>&nbsp;</td>
	<td>The name of the first or next attribute associated with
	the specified node, or null if there are none
	remaining.</td>
</tr>
</table>
<h4 id='valuemxmldomhandlenodeattrib'>$$VALUE^MXMLDOM(HANDLE,NODE,ATTRIB)</h4>

<p>Retrieves the value associated with the named attribute. The parameters for this API are listed in Table 13 by type, requirement (yes or no), and description.</p>
<table>
<caption>Table 13: $$VALUE^MXMLDOM—Retrieve value associated with named attribute</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>HANDLE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The value returned by the $$EN^MXMLDOM call that
	created the in-memory document image.</td>
</tr>
<tr>
	<td>NODE</td>
	<td>Integer</td>
	<td>Yes</td>
	<td>The node whose attribute value is being retrieved.</td>
</tr>
<tr>
	<td>ATTRIB</td>
	<td>String</td>
	<td>No</td>
	<td>The name of the attribute whose value is being
	retrieved by this call.</td>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>&nbsp;</td>
	<td>The value associated with the specified attribute.</td>
</tr>
</table>
<h3 id='vista_xml_parser_usage_example'>VistA XML Parser Usage Example</h3>

<p>This is a simple example of how to use the VistA XML Parser with an XML document (file). The XML file contains a parent node named BOOKS. Nested within that parent node are child nodes named TITLE and AUTHOR.</p>

<p>Remember the following:</p>

<blockquote>
<p>The parent node is the node whose child nodes are being retrieved.</p>
</blockquote>

<blockquote>
<p>The child node, if specified, is the last child node retrieved. The function will return the next child in the list. If the parameter is zero or missing, the first child is returned.</p>
</blockquote>

<h4 id='create_an_xml_file'>Create an XML File</h4>

<p><em>Figure 1: VistA XML Parser Use Example—Create XML File</em> <pre>
^TMP($J,1)=&lt;?xml version='1.0'?&gt;
^TMP($J,2)=&lt;!DOCTYPE BOOK&gt;
^TMP($J,3)=&lt;BOOK&gt;
^TMP($J,4)=&lt;TITLE&gt;Design Patterns&lt;/TITLE&gt;
^TMP($J,5)=&lt;AUTHOR&gt;Gamma&lt;/AUTHOR&gt;
^TMP($J,6)=&lt;AUTHOR&gt;Helm&lt;/AUTHOR&gt;
^TMP($J,7)=&lt;AUTHOR&gt;Johnson&lt;/AUTHOR&gt;
^TMP($J,8)=&lt;AUTHOR&gt;Vlissides&lt;/AUTHOR&gt;
^TMP($J,9)=&lt;/BOOK&gt;
</pre></p>

<p>Invoke Simple API for XML (SAX) Interface</p>

<p><em>Figure 2: VistA XML Parser Use Example—Invoke SAX Interface</em> <pre>D EN^MXMLTEST($NA(^TMP($J)),"V")&lt;Enter&gt;</pre></p>

<p>&#8230; Now see what happens.</p>

<p>Check Document Object Model (DOM) Interface</p>

<p><em>Figure 3: VistA XML Parser Use Example—Check DOM Interface</em></p>
<pre>
&gt;S HDL=$$EN^MXMLDOM($NA(^TMP($J))) &lt;Enter&gt;

 ; Write name of the first node
&gt;W $$NAME^MXMLDOM(HDL,1) &lt;Enter&gt;
BOOK
 
 ; Get the child of the node
&gt;S CHD=$$CHILD^MXMLDOM(HDL,1) &lt;Enter&gt;
 
 ; Write child name
&gt;W $$NAME^MXMLDOM(HDL,CHD) &lt;Enter&gt;
TITLE
 ;
 ; Get the text of the child.
&gt;W $$TEXT^MXMLDOM(HDL,CHD,$NA(VV)) &lt;Enter&gt;
1
 ;
&gt;ZWRITE VV &lt;Enter&gt;
VV(1)=Design Patterns
</pre>
<p>List All Sibling Nodes</p>

<p><em>Figure 4: VistA XML Parser Use Example—List Sibling Nodes</em> <pre>
&gt;S CHD=$$CHILD^MXMLDOM(HDL,1) &lt;Enter&gt;
&gt;S SIB=CHD &lt;Enter&gt;
&gt;F S SIB=$$SIBLING^MXMLDOM(HDL,SIB) Q:SIB'&gt;0 W !,SIB,?4,$$NAME^MXMLDOM(HDL,SIB) &lt;Enter&gt;
3 AUTHOR
4 AUTHOR
5 AUTHOR
6 AUTHOR
&gt;
</pre></p>

<h2 id='xml_document_creation_utility_apis'>XML Document Creation Utility APIs</h2>

<p>These Application Programmer Interfaces (API) have been developed to assist you in creating an XML document.</p>

<h4 id='xmlhdrmxmlutl'>$$XMLHDR^MXMLUTL()</h4>

<p>This extrinsic function returns a standard extensible markup language (XML) header for encoding XML messages. This API is a Supported Reference. Format: <pre>
$$XMLHDR^MXMLUTL()
</pre></p>
<table>
<caption>Table 14: $$XMLHDR^MXMLUTL(STR)—Return a standard XML Message Headers</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>&nbsp;</td>
	<td>Standard XML header.</td>
</tr>
</table>
<p>Example: <pre>
&gt;S X=$$XMLHDR^MXMLUTL
&gt;W X
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
</pre></p>

<h4 id='symencmxmlutlstr'>$$SYMENC^MXMLUTL(STR)</h4>

<p>This extrinsic function replaces reserved XML symbols in a string with their XML encoding for strings used in an extensible markup language (XML) message. This API is a Supported Reference. Format: <pre>
$$SYMENC^MXMLUTL(STR)
</pre></p>
<table>
<caption>Table 15: $$SYMENC^MXMLUTL(STR)—Encoded Strings in XML Messages</caption>
<tr>
	<th>Parameter</th>
	<th>Type</th>
	<th>Required</th>
	<th>Description</th>
</tr>
<tr>
	<td>STR</td>
	<td>String</td>
	<td>Yes</td>
	<td>String to be encoded in an XML message</td>
</tr>
<tr>
	<td>Return value</td>
	<td>String</td>
	<td>&nbsp;</td>
	<td>The input string with XML encoding replacing reserved XML symbols.</td>
</tr>
</table>
<p>Example: <pre>
&gt;S X=$$SYMENC^MXMLUTL("This line isn't &amp;""&lt;XML&gt;"" safe as is.")
</pre></p>

<h2 id='entity_catalog'>Entity Catalog</h2>

<p>The entity catalog is used to store external entities and their associated public identifiers. When the XML parser encounters an external entity reference with a public identifier, it first looks for that public identifier in the entity catalog. If it finds the entity, it retrieves its value. Otherwise, it attempts to retrieve the entity value using the system identifier. The problem with using system identifiers is that they often identify resources that may have been relocated since the document was authored. (This is analogous to the problem with broken links in HTML documents.) Using public identifiers and an entity catalog allows one to build a collection of commonly used and readily accessible external entities (e.g., external document type definitions).</p>

<p>XML ENTITY CATALOG (#950) The entity catalog is a VA FileMan-compatible file that is very simple in structure:</p>
<table>
<caption>Table 16: XML ENTITY CATALOG file (#950)—Stores external entities and assoc public identifiers</caption>
<tr>
	<th>Field #</th>
	<th>Field Name</th>
	<th>Datatype</th>
	<th>Description</th>
</tr>
<tr>
	<td>.01</td>
	<td>ID</td>
	<td>Free text (1-250)</td>
	<td>The public identifier associated with this entity.</td>
</tr>
<tr>
	<td>1</td>
	<td>VALUE</td>
	<td>Word Processing</td>
	<td>The text associated with the entity.</td>
</tr>
</table></body></html>
